## 第二章---Java编程基础

#### 数组创建

1. `数据类型[]  数组名 = null;`

2. `数据类型[]  数组名;`

   `数组名 = new 数据类型[长度];`

注：如果在创建时就对数组进行赋值，可以不填数组长度。例：`int[] a = new int[]{1, 2, 3, 4}` 该方法称为静态初始化，之前两种为动态初始化

#### 数组的常见操作

1. 升序排序
   - 导入包：`import java.util.Arrays`
   - `Arrays.sort(需要被排序的数组)`

#### 二维数组

- 创建：

  1.  `数据类型[][] 数组名 = new 数据类型[行的个数][列的个数];`

  2. 列数不确定时：`数据类型[][] 数组名 = new 数据类型[行的个数][]`

  3. 直接创建：`数据类型[][] 数组名 = {{数值}, {数值}, {数值}}`


#### 增强for循环

- 可用于数组的循环遍历输出
- 用法 `for (数据类型 变量名 : 遍历的目标)`

#### 基本数据类型和引用数据类型

1. 基础数据类型
   - 整数类型：long、int、short、byte
   - 浮点类型：float、double
   - 字符类型：char
   - 布尔类型：boolean
2. 引用数据类型
   - 大致包括：类、接口类型、数组类型、枚举类型、注解类型、字符串型

#### 方法的重载

表示同一个作用域中，方法名相同但参数类型与个数不同的方法。

## 第三章---面向对象（上）

#### 对象的创建与使用

1. 通过new来开辟堆内存空间，将对象指向对应的内存空间，堆内存中存放对象的方法属性，对象名储存在栈内存

#### 对象的引用传递

1. 类属于引用数据类型，引用数据类型就是指内存空间可以同时被多个栈内存引用。

#### 访问控制

1. private：私有访问权限，被修饰后只能在本类中进行访问
2. default：默认访问权限，被修饰后只能被本包中的所有类访问
3. protected：保护访问权限，被修饰后只能被本包中的所有类以及不同包的子类访问
4. public：公共访问权限，可以被所有类访问

#### 封装性

1. 使用private关键字进行封装，并提供setter和getter方法进行设置和获取

#### 构造方法

1. 构造方法在实例化对象时自动调用
2. 构造方法名称前部能有任何返回值类型的声明
3. 注意点：
   - 构造方法通常用public修饰

#### this关键字

1. 使用this调用本类中的属性
2. 使用this调用成员方法
3. 使用this调用本类中的构造方法
4. 注意点
   - 使用this调用构造方法中，只能在一个构造方法中调用另一个构造方法，且使用this调用构造方法的语句必须写在第一句，且只能出现一次
   - 不能在一个类中的两个构造方法中使用this互相调用

#### 代码块

###### 普通代码块

- 在方法或语句中的代码块
- 起到分隔作用域的作用，限定局部代码块

###### 构造代码块

- 直接定义在类中的代码块
- 每次实例化对象之前都会调用构造代码块
- 实例化对象时，先调用构造代码块，再调用构造方法

#### static关键字

###### 静态属性

- 被static修饰后的属性会变为公共属性，该属性只会被分配一块内存空间，并且被所有对象共享，只要某个对象修改了一次，所有对象的该属性值都会发生改变
- 注意点：static只能修饰成员变量，不能修饰局部变量

###### 静态方法

- 被修饰后的方法，可以直接使用类名进行调用

###### 静态代码块

- 当类被加载时，静态代码块会执行。
- static修饰的量会随着class文件一同加载，其优先级最高。
- 静态代码块只有在类的第一次使用时才会被加载，并且只会加载一次。

### 第四章---面向对象（上）

#### 类的继承

1. 继承的关键字：extends
2. 子类可以继承父类的成员，子类不可以直接调用父类中的私有成员
3. 类与类之间可以多层继承，但是不能多重继承

###### 方法的重写

- 子类可以重写父类中的方法，重写的方法必须具有相同的方法名，参数列表和返回值类型，并且重写的方法不能有比父类方法更严格的访问权限

###### super关键字

- 直接访问父类中的成员

- 通过super关键字访问父类的构造对象格式为`super();`

- 注意点：

  - | 区别点   | this                                                   | super                                        |
    | -------- | ------------------------------------------------------ | -------------------------------------------- |
    | 属性访问 | 访问本类中的属性，如果本类中没有该属性，则从父类中寻找 | 直接访问父类中的属性                         |
    | 方法     | 访问本类中的方法，如果本类中没有该方法，则从父类中寻找 | 直接访问父类中的方法                         |
    | 调用构造 | 调用本类构造方法，必须放在构造方法的首行               | 调用父类构造方法，必须放在子类构造方法的首行 |

###### final关键字

- 使用final修饰的类不能被子类重写

###### 抽象类

- 使用abstract关键字修饰
- 包含一个以上抽象方法的类必须是抽象类，并且都需要用abstract关键字修饰
- 抽象方法只需要声明，不需要实现
- 如果一个类继承了抽象类，该类必须实现抽象类中的所有方法
- 注意点：
  - 抽象方法不能被private修饰，因为抽象方法必须被子类实现，如果使用了private声明，则子类无法实现该方法

###### 接口

- 接口使用interface关键字声明

- 接口内的所有方法都是抽象的
- 接口是有全局常量和公共的抽象方法组成
- 一个接口可以继承多个父接口
- 接口中的属性默认使用`public static final`进行修饰，即全局常量
- 接口中的方法默认用`public abstract`进行修饰，即抽象方法
- 如果接口声明为public则接口中的变量和方法全部为public
- 子类通过implements关键字实现接口，并且子类需要实现接口中的所有抽象方法
- 一个类可以实现多个接口
- 注意点：
  - JDK8之后新加特性：
    - 允许我们在接口中定义默认方法(default)和静态方法(static)，这两种方法都可以有方法体
    - 静态方法只能通过接口名调用，默认方法只能通过接口实现类的对象来调用
    - 如果接口中的默认方法无法满足某个实现类的需要，那么该实现类可以覆盖默认方法，即重写
    - 当一个类继承了多个接口时，出现多个接口中静态方法一模一样时并不会报错，因为静态方法是通过接口名来调用
    - 当一个类继承了多个接口时，出现多个接口中默认方法一模一样时会产生错误，因为默认方法是用实现类的对象来调用，此时编译器无法区分两个默认方法，除非该实现类对此默认方法进行重写

#### 多态

###### 多态概述

- 不同的对象调用同一个方法时，表现出不同的行为
- Java中多态的主要形式
  - 方法的重载
  - 对象的多态性(方法重写)

###### 对象类型的转换

1. 向上转型
   - 格式：父类类型 父类对象 = 子类实例；
   - 注意点：
     - 向上转型时，子类单独定义的方法会丢失，无法通过转型后的对象来访问子类中的非继承方法

2. 向下转型
   - 格式：子类类型 子类对象 = (子类) 父类对象;
   - 注意点：
     - 向下转型的前提是他进行过向上转型
     - 向下转型只能转型为向上转型时的那个子类对象

3. 注意点：
   - 当父类对象引用变量引用子类对象时，被引用对象的类型决定了调用谁的成员方法，引用变量类型决定可调用的方法，如果子类中没有覆盖该方法，那么会去父类中寻找
     - 举例：X x = new Y();
     - X决定了只能调用X中定义的方法，Y决定了调用的方法具体是谁的方法。x对象只能调用X中定义的方法或者Y中重写的X中定义的方法，不能调用Y中独立的方法。
   - 继承链中对象方法的调用优先级：this.show(O) --> super.show(O) --> this.show((super)O) --> super.show((super)O)

###### instanceof关键字

1. 用于判断一个对象是否是某个类或接口的实例
2. 格式：对象 instanceof 类(或接口)

#### Object类

1. 每个类都直接或间接继承Object类

2. Object类中的常用方法

   - | 方法名称          | 方法说明                 |
     | ----------------- | ------------------------ |
     | boolean equals()  | 判断两个对象是否相等     |
     | int hashCode()    | 返回对象的散列码值       |
     | String toString() | 返回对象的字符串表现形势 |

     

3. 可以对Object类中的方法进行重写

#### 内部类

在一个类的内部定义另一个类，这样的类被称为内部类

###### 成员内部类

1. 在一个类中定义类，这样的类称为成员内部类，成员内部类可以访问外部类的所有成员
2. 如何通过外部类来访问内部类
   - 通过外部类来创建内部类角色
     - 格式：外部类名.内部类名 变量名 = new 外部类名().new 内部类名()

###### 局部内部类

1. 定义在某个局部范围中的类，在方法中定义，有效范围也只限与方法内部
2. 局部内部类可以访问外部类的所有成员变量和方法，而局部内部类中变量和方法只能在所属方法中访问

###### 静态内部类

1. 被static关键字修饰的成员内部类被称为静态内部类
2. 静态内部类只能访问外部类中的静态成员，通过外部类访问静态内部类时，可以跳过外部类直接访问静态内部类

###### 匿名内部类

1. Java中调用某个方法时，如果该方法的参数的接口类型，除了可以传入一个接口实现类外，还可以使用实现接口的匿名内部类作为参数，在匿名内部类中直接完成方法的实现

2. 创建匿名内部类的基本语法格式

   - ```java
     new 父接口() {
         // 匿名内部类实现部分
     }
     ```

3. 匿名内部类一本用于那些只需要使用一次的类

#### 异常

###### 何为异常

1. 异常类(Exception)  ---->父类(Throwable)
   - 子类(RuntimeException)及其子类表示运行中的异常
   - 其他子类都表示编译时异常

2. Throwable类的常用方法

   - | 方法声明               | 功能描述                                                     |
     | ---------------------- | ------------------------------------------------------------ |
     | String getMessage()    | 返回异常的消息字符串                                         |
     | String toString()      | 返回异常信息的简单描述                                       |
     | void printStackTrace() | 获取异常类名和异常信息，以及异常出现在程序中的位置，把信息输出在控制台 |

   - 因为Error和Exception都继承自Throwable类，所以他们都拥有这些方法

###### try...catch和finally

异常捕获

1. 语法格式

   - ```java
     try {
         // 程序代码块
     }
     catch (ExceptionType(Exception类及其子类) e) {
         // 对ExceptionType的处理
     }
     ```

2. catch代码对异常处理完毕后，程序仍会向下执行，而不会终止程序

3. finally代码块中无论程序是否发生异常，该代码块中的代码依旧会运行，即使在catch中使用了return来结束当前方法。

###### throws关键字

- 概念：
  - Java允许在方法的后面使用throws关键字对外声明该方法有可能发生异常，这样调用者在调用方法时，就明确的知道该方法是否有异常，并且必须在程序中对异常进行处理，否则编译无法通过
  - 在调用使用throws关键字的方法时，如果不知道如何处理声明抛出的异常，也可以使用throws继续抛出，这样程序也能编译通过，但是程序一旦发生异常，并且异常没有被处理，程序就会非正常终止。

###### 自定义异常

@未完成
